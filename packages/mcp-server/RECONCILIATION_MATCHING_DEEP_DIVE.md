# Caliper Semantic Harmony Engine: Reconciliation Matching Master Specification

## 1. Introduction: The Design-to-Code Reconciliation Problem

The Caliper Semantic Harmony Engine (SHE) is designed to solve the "Structural Parity" problem in frontend engineering. Modern design systems are conceptual, while browser implementations are concrete. Reconciling these requires more than a simple DOM diff; it requires a semantic understanding of intent.

This document details the matching architecture that powers the `caliper_reconcile` tool, ensuring the AI agent can audit complex, multi-breakpoint layouts with mathematical precision.

---

## 2. Global Data Structures: The Input Schema

### 2.1 The "Actual" State: `CaliperNode` (Live Browser)

The actual state is extracted by the `agent-bridge` DOM walker. It is an absolute representation of the computed reality.

```typescript
/**
 * Extracted directly from live DOM via getComputedStyle
 * and getBoundingClientRect.
 */
interface CaliperNode {
    // Identity & Tracking
    agentId: string;           // Pointer for BitBridge synchronization
    tag: string;               // e.g., "DIV", "BUTTON", "SECTION"
    htmlId?: string;           // Standard id attribute
    classes: string[];         // Cleaned class list (no CSS module hashes)
    textContent?: string;       // Direct visible text
    
    // Geometry (Absolute Pixels)
    rect: {
        top: number;
        left: number;
        width: number;
        height: number;
        bottom: number;
        right: number;
    };
    
    // Core Visual Properties (Pre-Normalized)
    styles: {
        display: string;
        position: string;
        padding: { top: number; right: number; bottom: number; left: number; };
        margin: { top: number; right: number; bottom: number; left: number; };
        border: { top: number; right: number; bottom: number; left: number; };
        
        // Typography
        fontSize: number;
        fontWeight: string;
        lineHeight: number | "normal";
        letterSpacing: number | "normal";
        color: string;           // RGB(A) standard
        
        // Visuals
        backgroundColor: string;
        borderColor: string;
        borderRadius: string;
        boxShadow?: string;
        opacity: number;
        outline?: string;
        outlineColor?: string;
        zIndex: number | null;
        
        // Layout
        flexDirection?: string;
        justifyContent?: string;
        alignItems?: string;
        gap: number | null;
    };
    
    // Recursive Structure
    children: CaliperNode[];
    depth: number;
}
```

### 2.2 The "Expected" State: `SemanticNode` (Design Intent)

The expected state is generated by logic inside the MCP server. It handles CSS functions, Tailwind utility mapping, and Design Token resolution.

```typescript
/**
 * Represents the intention of the design system.
 */
interface SemanticNode {
    id: string;                // Matching key
    tag: string;               // Expected tag (includes semantic fallbacks)
    classes: string[];         // Tailwind or CSS utility classes
    textContent?: string;      // Literal expected text
    inferredStyles: {
        [K in keyof CaliperComputedStyles]?: string | number;
    };
    rawStyles?: string;        // Specific style overrides
    children: SemanticNode[];
}
```

---

## 3. The Pre-Processing Unit: Token Resolver & XYZ Hub

Matching cannot happen without normalization. The `TokenResolverService` acts as the sensory processor for the engine.

### 3.1 The High-Precision Hub (XYZ D65)

To compare colors accurately, SHE ignores gamuts and uses a central XYZ (D65) hub.

1.  **Input Parsing**: Supports RGB, HSL, HWB, Lab, LCH, and P3.
2.  **White-Point Correction**: Uses the **Bradford Transformation** to map D50 colors (Standard Lab) to the D65 (Standard Web) white-point.
3.  **OKLAB Target**: Final normalization results in an OKLAB triplet ($L, a, b$), which provides the most perceptually accurate "Delta-E" distance measurement ($O(1)$ lookup for exact tokens, $O(T)$ for nearest-neighbor).

### 3.2 Spacing & Dimensonal Resolution

Calculates absolute pixel targets for relative design intents.

*   **REMs**: Resolved using `metrics.rootFontSize` (Default: 16px).
*   **EMs**: Resolved using the inherited parent `fontSize` tracked during recursive descent.
*   **Math**: Resolved via the $O(N)$ **Linear Math Trace** (handles `calc`, `clamp`, `min`, `max`).

---

## 4. Algorithmic Deep-Dive: The Semantic Matcher

The `SemanticMatcher` is an $O(N \times C^2)$ engine responsible for pairing nodes between the Actual and Expected trees.

### 4.1 Signal Weighting Logic

The matcher calculates a "Similarity Score" ($0$ to $100$) for every potential pairing candidate.

| Signal ID | Weight (pts) | Algorithmic Logic |
| :--- | :--- | :--- |
| `ID_MATCH` | 100 | `actual.htmlId === expected.id` |
| `TAG_EXACT` | 100 | `actual.tag === expected.tag` |
| `TAG_SEMANTIC` | 50 | Uses the Semantic Equivalence Map (e.g., div $\leftrightarrow$ section) |
| `TEXT_EXACT` | 80 | Case-insensitive, trimmed comparison |
| `TEXT_FUZZY` | 40 | String contains / Regex overlap |
| `CLASS_OVERLAP`| 60 | (Intersection Set / Union Set) * Weight |
| `LAYOUT_STRICT`| 30 | Display + FlexDirection matching |
| `CHILD_COUNT` | 20 | Equality of immediate children array length |
| `TAG_CLASH` | -50 | Impossible pairings (e.g., matching text to a `canvas`) |

### 4.2 Greedy Hungarian Alignment

For pairs containing children, we use a specialized alignment algorithm:

1.  **Candidate Matrix Generation**: Create a matrix of SIMILARITY scores for every Actual Child against every Expected Child.
2.  **Sorting**: Flatten the matrix and sort candidates by score (Descending).
3.  **Locking Loop**:
    *   Pick the top-scoring candidate.
    *   If `Score >= 30`, lock the pair $(A_i, E_j)$.
    *   Mark $A_i$ and $E_j$ as "Occupied".
    *   Repeat until no viable candidates remain.
4.  **Result**: Produces an array of `NodePair` objects.

### 4.3 Hierarchical Recursion ($O(N)$)

The pairing logic descends recursively. This preserves structural integrity; the engine will never match a child of the header to a node in the footer, even if their scores are theoretically high.

---

## 5. Property Reconciliation Engine: The Delta Pipeline

Once nodes are paired, the system performs a multi-phase visual audit.

### 5.1 Registration & Basis Logic

The `PROPERTY_REGISTRY` defines how browser metrics map to design code.

```typescript
const PROPERTY_REGISTRY: PropertyDefinition[] = [
    { id: "gap", actual: node => node.styles.gap, basis: parentWidth },
    { id: "paddingTop", actual: node => node.styles.padding.top, basis: parentWidth },
    { id: "fontSize", actual: node => node.styles.fontSize, basis: 16 },
    { id: "color", actual: node => node.styles.color, basis: "OKLAB" }
];
```

### 5.2 Discrepancy (Delta) Classification

Every delta is categorized by severity to help the AI prioritize fixes:

1.  **EXACT**: Match within tolerance (e.g., $0.05\%$ color diff or $0.2px$ sub-pixel jitter).
2.  **MINOR**: Visible discrepancy but structurally safe (e.g., $4px$ padding error).
3.  **MAJOR**: Design intent failure (e.g., $> 8px$ error or color contrast failure).

---

## 6. Transport: BitBridge Binary Protocol

Caliper uses a custom binary protocol to stream layout snapshots to the matching engine.

### 6.1 Buffer Architecture

```text
[MAGIC: 4b] [VERSION: 1b] 
[DICT_COUNT: 4b]
   [STR_LEN: 2b][DATA: ...n]
[NODE_STREAM: ...m]
   [TAG_ID: 2b][SEL_ID: 2b]
   [FLAGS: 1b] (HasText, HasStyles, etc)
   [METRICS: 24b] (F32 x 6)
   [STYLES: ...v]
   [CHILD_COUNT: 2b]
```

This packing ensures that snapshots for components with 500+ nodes remain under 50KB, preventing WebSocket congestion and maintaining low-latency audits.

---

## 7. AI Feedback Architecture

The result of the matching and reconciliation is a structured report returned to the LLM.

### 7.1 The AI Instruction Set

The report is specifically formatted to be consumed by an Agent:

1.  **Match Summary**: High-level "State of the UI."
2.  **CSS Recommendations**: Generated CSS patches that include the token names (e.g., `var(--blue-500)`).
3.  **Token Miss Report**: Alerts the AI if it used a hardcoded value that *almost* matched a token (e.g., `#ff0202` vs Red-500).
4.  **Structural Alerts**: Warnings if the DOM depth differs drastically from the design intent.

### 7.2 Performance Benchmarks

| Metric | Target | Reality (Current SHE v2) |
| :--- | :--- | :--- |
| **Max Tree Depth** | 20 levels | Supports 100+ (Linear) |
| **Matching Speed** | < 10ms | ~1.8ms per 100 nodes |
| **Color Precision**| Lab Delta-E | XYZ Hub (Bradford D65) |
| **Memory Leakage** | Zero | Object Pooling implemented |

---

## 8. Error Handling & Resilience

-   **Fragmented Design**: If the AI passes a partial HTML fragment, the root matcher finds the most likely anchor in the live DOM using spatial context.
-   **Z-Index Collision**: The engine audits stacking contexts, identifying when a `z-index` is redundant or failing based on parent context.
-   **CSS Modules**: The system automatically filters out runtime hashes from class lists (e.g., `Header_root_a1b2` $\to$ `Header_root`) during the Similarity Phase.

---

## 9. Future Strategy: SHE v3.0 Roadmap

1.  **Animation Reconciliation**: Auditing transition durations and easing curves against tokens.
2.  **Interaction States**: Real-time diffing of `:hover` and `:active` CSS properties.
3.  **Container Query Awareness**: Dynamic basis adjustments for components inside sub-grid containers.
4.  **Accessibility (A11y) Mapping**: Structural audit of ARIA roles against design landmarks.

---

## 10. Conclusion

The Reconciliation Matching Architecture of Caliper is built on a foundation of scientific color spaces, linear-time complexity, and high-precision binary transport. It provides the definitive bridge between the conceptual world of design and the concrete reality of the browser, enabling AI Agents to act with perfect visual awareness.

---

### [SECTION 11: APPENDICES - EXHAUSTIVE PROPERTY DEFINITIONS]

#### 11.1 SPACING REGISTRY
1. **paddingTop**: `getComputedStyle(node).paddingTop` -> Normalized to pixels.
2. **paddingRight**: `getComputedStyle(node).paddingRight` -> Normalized to pixels.
3. **paddingBottom**: `getComputedStyle(node).paddingBottom` -> Normalized to pixels.
4. **paddingLeft**: `getComputedStyle(node).paddingLeft` -> Normalized to pixels.
5. **marginTop**: `getComputedStyle(node).marginTop` -> Normalized to pixels.
6. **marginRight**: `getComputedStyle(node).marginRight` -> Normalized to pixels.
7. **marginBottom**: `getComputedStyle(node).marginBottom` -> Normalized to pixels.
8. **marginLeft**: `getComputedStyle(node).marginLeft` -> Normalized to pixels.
9. **gap**: `getComputedStyle(node).gap` -> Partial split into `column-gap` and `row-gap`.
10. **width**: `node.getBoundingClientRect().width` -> Includes fractional subpixels.
11. **height**: `node.getBoundingClientRect().height` -> Includes fractional subpixels.

#### 11.2 TYPOGRAPHY REGISTRY
1. **fontSize**: `getComputedStyle(node).fontSize` -> Comparison vs `rem`/`px` design tokens.
2. **fontWeight**: `getComputedStyle(node).fontWeight` -> Weighted numeric comparison (400 vs 700).
3. **lineHeight**: `getComputedStyle(node).lineHeight` -> Normalized to ratio or pixels.
4. **letterSpacing**: `getComputedStyle(node).letterSpacing` -> Normalized to pixels.
5. **color**: `getComputedStyle(node).color` -> Converted to OKLAB (L, a, b).
6. **fontFamily**: `getComputedStyle(node).fontFamily` -> String sequence comparison.

#### 11.3 VISUAL REGISTRY
1. **backgroundColor**: `getComputedStyle(node).backgroundColor` -> Converted to OKLAB.
2. **borderColor**: `getComputedStyle(node).borderColor` -> Per-side analysis if differing.
3. **borderRadius**: `getComputedStyle(node).borderRadius` -> Support for elliptical syntax.
4. **boxShadow**: `getComputedStyle(node).boxShadow` -> Multi-layer shadow parsing and diffing.
5. **opacity**: `getComputedStyle(node).opacity` -> Float comparison (0.0 to 1.0).
6. **outline**: `getComputedStyle(node).outline` -> Width, color, and style components.
7. **zIndex**: `getComputedStyle(node).zIndex` -> Relative stacking context audit.

#### 11.4 LAYOUT REGISTRY
1. **display**: `getComputedStyle(node).display` -> Enum match (flex, grid, block, none).
2. **flexDirection**: `getComputedStyle(node).flexDirection` -> (row, column, reverse).
3. **justifyContent**: `getComputedStyle(node).justifyContent` -> (start, end, center, space-between).
4. **alignItems**: `getComputedStyle(node).alignItems` -> (start, end, center, stretch).
5. **flexWrap**: `getComputedStyle(node).flexWrap` -> (wrap, nowrap).
6. **flexGrow**: `getComputedStyle(node).flexGrow` -> Numeric expansion factor.
7. **flexShrink**: `getComputedStyle(node).flexShrink` -> Numeric compression factor.

### [SECTION 12: AGENTIC FEEDBACK LOGIC]

#### 12.1 CSS REPAIR STRATEGIES
When a delta is found, the engine suggests a repair based on the framework:
- **Tailwind**: Suggests the nearest class (e.g., `p-4` instead of `padding: 1rem`).
- **Inline**: Suggests a direct style injection for one-off tweaks.
- **Variable**: Recommends a design token reference (`var(--primary-color)`).

#### 12.2 TOKEN MISMATCH DETECTION
The engine tracks "Near-Token" values. If a color is `#3b82f6` (Tailwind blue-500) but uses `#3b82f7`, the audit identifies this as a "Missed Token" and instructs the AI to migrate to the standard variable.

### [SECTION 13: PERFORMANCE GUARANTEES AT SCALE]

1. **Memory Ceiling**: The BitBridge walker uses a flat ArrayBuffer, ensuring memory usage stays constant regardless of tree depth.
2. **Execution Boundary**: Reconciliation always runs in a background worker inside the MCP to prevent blocking the AI response streaming.
3. **JIT Schema Validation**: Inferred styles are cached uniquely per class string, making subsequent reconciliations of the same component near-instantaneous.

---

*Copyright Â© 2026 Caliper Team. High-Precision Design Engineering.*
